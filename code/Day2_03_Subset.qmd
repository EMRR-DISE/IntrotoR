---
title: "Subset Data"
author: "Perry S"
format:
  html:
    code-link: true
code-copy: true
execute: 
  message: false
  warning: false
---

```{r}
#| include: false

library(tidyverse)
library(here)

df_wq <- read_csv(here("data/WQ_P8D7.csv"))
```

## Introduction

Let's talk a bit about the structure of a data frame. Data frames are 2-dimensional objects (row x column). Every entry in a data frame has a unique **index** that's defined by which row x column it's in. Since we rarely want to work on the entire data frame at once, we can use these indices to **subset** our data.

## Basic Subsetting

For example, if I want to look at the value in the 1st row of the 2nd column, I can call the index \[1,2\]:

```{r}
df_wq[1,2]
```

or, perhaps, the 2nd row of the 1st column:

```{r}
df_wq[2,1]
```

We can also access an entire row or column at once:

```{r}
df_wq[1,] # entire row
```

```{r}
df_wq[,1] # entire column
```

You can also subset multiple columns/rows at once by using a `:`

```{r}
df_wq[,2:4] # all rows, 2-4th columns
```

## Subset by Column Names

Subsetting is very powerful. However, if we specify values by their numerical index, we can get confused about what we're accessing. For example, if I wanted to work with `DissAmmonia` data, I would have to know that it's the 4th column in my data frame. That can get unwieldy with complex datasets.

Instead, we can use the **column header** to call a particular column:

```{r}
df_wq['DissAmmonia']
```

```{r}
str(df_wq['DissAmmonia'])
```

This returns a tibble that only contains the relevant column.

We can also call the column as a vector (this is the more common syntax):

```{r}
df_wq$DissAmmonia
```

```{r}
str(df_wq$DissAmmonia)
```

To select multiple columns by name, we use our `:` technique within the `select` function from the `dplyr` package (in tidyverse):

```{r}
df_wq %>% select(Station:Pheophytin)
```

If this is the only data I want to work with, I can store this as a unique object:

```{r}
df_chlpheo <- df_wq %>% select(Station:Pheophytin)
```

```{r}
glimpse(df_chlpheo)
```

::: callout-note
### Tidyverse Pipes

You'll notice I used some new syntax, namely, the `%>%`. This is called the **pipe operator**, **Operators** are functions that allows one to perform operations on other functions/variables. The pipe operator specifically allows you to chain together tidyverse commands. Using pipes helps keep code readable and easy to follow.
:::

## Subset By Row Values

Another common goal is to subset by particular row values -- say, only a given station, date range, or analyte value range. Tidyverse also has functions for this! Specifically, we use `filter` from the `dplyr` package:

```{r}
df_p8 <- df_wq %>% filter(Station == 'P8')
```

```{r}
unique(df_p8$Station)
```

------------------------------------------------------------------------

## [Aside:]{.underline} Logical Operators

### *equality* (`==`) and *negate equality* (`!=`)

Note we used another new symbol: `==`. This is the equality operator, a type of **logical operator**. Logical operators allow us to dictate what our code does via logical statements; they are the backbone of programming.

**Equality**, as we saw above, tells the code to find all values from the right-hand side that are equal to the left-hand side.

**Negate** does the opposite; it gives us the values that do not match. Here, we apply it to the equality operator, but note that `!` is the **general negate operator**; it can be applied to *any logical statement*.

```{r}
df_notp8 <- df_wq %>% filter(Station != 'P8')
```

```{r}
unique(df_notp8$Station)
```

### *and* (`&`) and *or* (`|`)

Sometimes, we want to filter by multiple commands at once. We can use this using the logical operators *and* (`&`) or *or* (`|`):

```{r}
df_wq %>% filter(Station == 'P8' & Date == '2020-01-16')
```

```{r}
df_wq %>% filter(Date == '2020-01-16' | Date == '2020-01-22')
```

### *less than* `<` and *greater than* `>`

Sometimes, we want all values above or below:

```{r}
df_wq %>% filter(Date >= '2020-02-01')
```

```{r}
df_wq %>% filter(Date <= '2020-06-30')
```

```{r}
df_wq %>% filter(!(Date >= '2020-06-30')) # same thing but using negate
```

What if we want data in between two dates? We can use the `&` operator!

```{r}
df_wq %>% filter(Date >= '2020-02-01' & Date <= '2020-06-30')
```

### *in* (`%in%`)

What if we wanted to subset by five specific dates? We could string together multiple `|` commands, but that can become unwieldy to write.

What if I instead had a vector of those five specific dates? Then I could subset by all the values in my dataset that match one of the values in that vector.

This is what the `%in%` function does:

```{r}
df_wq %>% filter(Date %in% c('2020-02-14','2020-03-06','2020-06-11','2021-03-05','2021-04-05'))
```

### Exercise

In one filter function, how would I select data that's either before 2020-02-28 *or* after 2022-11-01?

```{r}
#| code-fold: true
#| eval: false

df_wq %>% filter(Date <= '2020-02-28' | Date >= '2022-11-01')
```

------------------------------------------------------------------------

## Subset by Column and Row

Using our knowledge of pipes, it's easy to subset by column and row at the same time!

```{r}
df_wq %>% filter(Date == '2020-01-16' | Date == '2020-01-22') %>% select(Station:Pheophytin)
```

::: callout-note
### Formatting Code

Notice that above all the code is on the same line. This can be difficult to read. You can get around this by formatting your code. Personally, I like having different functions on different lines:

```{r eval=FALSE}
df_wq %>%
  filter(Date == '2020-01-16' | Date == '2020-01-22') %>%
  select(Station:Pheophytin)
```

You can also use `ctrl+shift+A` to auto-format code! Note that it looks different from above; this is fine. As long as you deem the code readable (and it works), you're set.

```{r eval=FALSE}
# original
df_wq %>% filter(Date == '2020-01-16' | Date == '2020-01-22') %>% select(Station:Pheophytin)

# ctrl+shift+A
df_wq %>% filter(Date == '2020-01-16' |
                   Date == '2020-01-22') %>% select(Station:Pheophytin)
```
:::

------------------------------------------------------------------------

## Subset by Dates

What if I want to subset all values in a given year? If I had a vector of all the years in my dataset, then I could simply use `%in%`! But how would I get that vector?

The `lubridate` package allows you to manipulate dates. Since dates are complicated in R, we won't go into too much detail. However, a few useful functions are `day`, `month`, and `year`, which return the days, months, and years (as vectors) from a vector of dates that are of the **Date class**:

*Original:*

```{r}
df_wq$Date
```

```{r}
class(df_wq$Date) # check that it's the correct class
```

*Days:*

```{r}
day(df_wq$Date)
```

*Months:*

```{r}
month(df_wq$Date)
```

*Years:*

```{r}
year(df_wq$Date)
```

One use for these functions is to subset. Say we want all entries from the year 2021:

```{r}
df_wq %>% filter(year(Date) %in% '2021')
```

```{r}
# same thing but using negate
df_wq %>% filter(
  !(year(Date) %in% c('2020','2022'))
  )
```

------------------------------------------------------------------------

## Subset `NA`

The final type of subset that we'll cover today is by `NA` data.

`NA` is a **logical constant** of length 1 which contains a missing value indicator:

```{r}
typeof(NA) # NA

typeof('NA') # not the same
```

Sometimes, we want to select only `NA` data or omit it entirely. Looking at the DON column, we see that there are `NA`s:

```{r}
unique(df_wq$DON) # returns unique values
```

A quicker way to check this is the `is.na` function:

```{r}
is.na(df_wq$DON)
```

This returns a logical vector. If I want to subset by this, I can use the `filter` function:

```{r}
df_wq %>%
  filter(is.na(df_wq$DON)) %>%
  select(Station, Date, DON)
```

**Question:** What operator would I use if I want all data *except* `NA`s (hint: I want to *negate* `NA`)

**Challenge Exercise**: How would I write this statement? (Hint: examples are above)

```{r}
#| code-fold: true
#| eval: false

df_wq %>%
  filter(!is.na(df_wq$DON)) %>% # use the ! operator before the function to negate it
  select(Station, Date, DON)
```
