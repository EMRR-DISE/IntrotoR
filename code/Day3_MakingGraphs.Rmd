---
title: "Day3_MakingGraphs"
author: "Nick Rasmussen"
date: "5/31/2024"
output:
  pdf_document:
    toc: true
    toc_float: true
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(include=TRUE, message=FALSE, warning=FALSE)
```

## Making Graphs in R

One of the greatest strengths of R is its ability to produce a wide variety of professional quality custom graphs. Today, we will cover the basics of visualizing data using the popular `ggplot2` package.

## Using base R graphics vs the `ggplot2` package

When you download R, there is a suite of packages that are included. These packages include functions for carrying out a variety of basic tasks, including making graphs. I used base R graphing functions for a number of years, and there's nothing wrong with using these functions. However, in more recent years, I have completely switched to using the `ggplot2` package and think it is a great package for new R users to know.

## Continuous vs categorical data

As we decide what type of plot to make, it is useful to consider the types of data we are plotting. Continuous data refers to numbers like water temperature. Categorical refers to types within a group (e.g., station).

## Load the required R packages

So without further ado, let's load the packages we need for today's tutorial. In addition to `ggplot2`, we will also load the `tidyverse` to do some basic tasks like reading in data sets and filtering data.

```{r load packages}

library(tidyverse) #suite of data science tools
library(here) #setting working directory
library(viridis) #color blind friendly color palettes
library(patchwork) #combining plots into panels

```

## Read in the dataset

We will continue to use the same EMP water quality data set that you used for the first two parts of this course.

```{r read in data}
here()
wqdata <- read_csv( here("data", "WQ_P8D7.csv"))

```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

## Look at at the data set

Let's take a quick look at the structure of the data to remind ourselves of the column names and data types in this data set

```{r}

glimpse(wqdata)

```

## Making a basic ggplot graph

The `ggplot2` package utilizes the grammar of graphics and creates plots in "layers". We will learn about some of the core "geometries" which are basically just types of plots. 

Let's start making plots, so we can learn the anatomy of the `ggplot()` function. We will begin with a histogram, which simply shows the distribution of data for a single variable. 

Within the `ggplot()` function, the first thing we should do is specify the data set we want to plot using the `data` argument. Then, we will indicate which column within the data set we want to plot. These are the most basic components. 

From here, we use the `+` sign to add layers upon the foundation we have built. In this case, we want a histogram, so we use the argument `geom_histogram()`. There are many types of graphs you can make and ggplot has similarly named arguments for each of them (e.g., `geom_point`, `geom_line`). We will look at more of these shortly.

```{r}

(plot_hist <- ggplot(data = wqdata, aes(x = WTSurface)) +
  geom_histogram()
)


```

The default number of bins do not work well for this small data set. We can make some manual adjustments within the `geom_histogram()` argument.


```{r}

(plot_hist2 <- ggplot(data = wqdata, aes(x = WTSurface)) +
  geom_histogram(bins = 8)
)


```

## Time series plots

Next, let's plot a time series of data. These plots are helpful for looking at monitoring data through time to identify patterns or for looking for outliers. For a histogram, there was only an x variable. For most types of plots, including time series plots, there are x and y variables to specify.

We will plot a year of Secchi depth data to see how it changes through the seasons. For simplicity, we will just plot the data for one station, P8. Each value for Secchi will be plotted as a point so we will use `geom_point()`.

```{r}

#filter data set to only data for station D7
wqdata_p8 <- wqdata %>% 
  filter(Station == "P8") 

#now plot this subset of the data
(plot_ts_points <- ggplot(data = wqdata_p8, aes(x = Date, y = Secchi)) +
  geom_point()
)

#you can also do the filtering and plotting all at once
(plot_ts_points2 <- wqdata %>% 
    filter(Station == "P8") %>% 
      ggplot(aes(x = Date, y = Secchi)) +
    geom_point()
)

```

We can start to see how Secchi depth changed over time, but it would be easier to look at with lines connecting the points. Let's add some, which will highlight how ggplot works by building layers. As you might expect, we add the lines using `geom_line()`.

```{r}

#time series plot with connecting lines
(plot_ts_points_lines <- ggplot(data = wqdata_p8, aes(x = Date, y = Secchi)) +
  geom_point()+
  geom_line())

#Because we are simply building upon the previous graph made with only the points, we can also use this shortened approach, which further demonstates that we are simply adding layers
(plot_ts_points_lines2 <- plot_ts_points +
  geom_line())

```

Now it is a little easier to see the patterns through time. We can see that Secchi depth varies seasonally, generally with low values in rainy winter months and high in dry summer months. Note there is a gap in the time series in 2021 to reflect a missing value.  

## Multiple time series per plot

We can easily plot multiple time series on the same graph in order to compare them. We will plot Secchi for both P8 and D7. These stations are in very different parts of the Estuary, so their turbidity dynamics are rather different.

```{r}

#time series plot with connecting lines for both stations
(plot_ts_points_lines_two <- ggplot(data = wqdata, aes(x = Date, y = Secchi, group = Station)) +
  geom_point(aes(color = Station))+
  geom_line(aes(color = Station)))

```

This plot clearly shows that Secchi depth is generally much higher at P8 than D7, indicating that turbidity is higher at D7.


## Scatterplots

Next, let's make a scatterplot. These plots are great for looking at relationships between pairs of continuous variables. As an example, we will plot dissolved organic carbon against total organic carbon. We will go back to using the dataset with both stations.

```{r}

(plot_scatter <- ggplot(data = wqdata, aes(x = DOC, y = TOC)) +
  geom_point()
)

```

There appears to be a strong relationship between these two variables. Let's add a trend line. As with the time series plot, we are building layers. However, we are not simply adding lines to connect the points, so we aren't using `geom_line()`. To plot a trend line, we use `geom_smooth()`. There are various smooths that could be applied, so we need to specify what we want. In this case, we use a linear model (LM). By default, a 95% confidence interval (dark gray) is added around the trend line (blue).

```{r}
(plot_scatter_trend <- plot_scatter +
   geom_smooth(method = lm)
   )


```

## Box and whisker plots

In scatter plots, we plot a continuous variable against another continuous variable. In some cases, we want to plot a continuous variable against a categorical variable. One type of plot that is useful in this situation is a box and whisker plot. These are great for initial data exploration and sometimes even in publications.

Microcystis abundance data is collected using a visual scoring system of 1 - 5, with 5 being the highest. Microcystis blooms are associated with high water temperature. Let's plot the Microcystis scores (categorical) against water temperature (continuous). 

Note that Microcystis scores are ordered categories (i.e., ordinal), so R read them in as numeric data. We will make this column a factor to indicate that these numbers are actually categories. if we don't do this, we won't get the plot we expect.

```{r}

#try making the plot with Microcystis as numeric type
(plot_bw1 <- ggplot(data = wqdata, aes(x = Microcystis, y = WTSurface)) +
   geom_boxplot()
   )
#doesn't produced the expected result because the Microcystis column is currently numeric instead of a factor

#make the plot correctly by specifying that Microcystis scores are categorical rather than numeric
(plot_bw2 <- ggplot(data = wqdata, aes(x = factor(Microcystis), y = WTSurface)) +
   geom_boxplot()
   )


```

Personally, I like to include all the raw data points on the box and whisker plots because it gives folks an even better understanding of the distribution of the data. To do this, we add a layer with `geom_jitter()`. It is called this because the points are "jittered" to minimize overlap among them.

```{r}

(plot_bw_points <- plot_bw2 +
   geom_jitter()
   )

```

## Barplots

In addition to box and whisker plots, you can make bar plots. Bar plots generally show less information than box and whisker plots, simply showing the means of a continuous variable by category. We will make a bar plot that is analogous to the box and whisker plot above.

```{r}

#first let's calculate the mean WTSurface by Microcystis score
wqdata_means <- wqdata %>% 
  group_by(Microcystis) %>% 
  summarize(temp_mean = mean(WTSurface))

#now make the bar plot
(plot_bar <- ggplot(data = wqdata_means, aes(x = factor(Microcystis), y = temp_mean)) +
   geom_bar(stat = 'identity')
   )

#another way to make the same plot
(plot_bar2 <- ggplot(data = wqdata_means) +
    geom_col(aes(x = factor(Microcystis), y = temp_mean))
    )

```

## Stacked bar plot

Sometimes we want to simultaneously show a total and it's component parts at the same time, which is where stacked bar plots are useful.

Let's go back to the subset of data for Station P8. We might want to look at Dissolved Ammonium and Dissolved Nitrate and Nitrite through time together.

```{r}

#first we will rearrange the data frame a bit to make plotting easier
wqdata_p8_nutrients <- wqdata_p8 %>% 
  #reduce data set down to just the needed columns
  select(Station, Date, DissAmmonia, DissNitrateNitrite) %>% 
  #convert from wide to long format
  pivot_longer(cols = c(DissAmmonia,DissNitrateNitrite), names_to = "Nutrient", values_to = "Value")

(plot_bar_stack_abs <- ggplot(data = wqdata_p8_nutrients, aes(x = Date, y = Value, fill = Nutrient)) +
   geom_bar(stat = 'identity')
   )

```

Perhaps we are more interested in the relative values rather than the absolute values. We just make a minor modification to the the code we used above.

```{r}
(plot_bar_stack_rel <- ggplot(data = wqdata_p8_nutrients, aes(x = Date, y = Value, fill = Nutrient)) +
   geom_bar(stat = "identity", position = "fill")
 )
```

## Faceted plots

Sometimes we want to show the same type of plot for multiple groups at once so we can compare them. It is easy to make multi-panel plots in `ggplot2` using facets. 

Above, we plotted Secchi depth for both stations on the same plot. Sometimes, it is more useful to create a two panel plot, in which each time series is plotted on a separate graph. 

```{r}

#faceted time series plot for Dissolved Ammonia
(plot_ts_points_lines_facet <- ggplot(data = wqdata, aes(x = Date, y = Secchi)) +
  geom_point()+
  geom_line())+
  facet_grid(Station~.)

```

Here's another example

```{r}

#time series plot for two analytes
(plot_bar_stack_abs_facet <- ggplot(data = wqdata_p8_nutrients, aes(x = Date, y = Value)) +
   geom_bar(stat = 'identity')+
  facet_grid(Nutrient~.)
)

```

By default, the y-axis is standardized across the panels. This is generally a good idea. However, we can change this if we like. Ammonia concentrations are much lower than nitrate + nitrite concentrations, which makes ammonia concentrations difficult to read on the plot. Let's use different y-axis ranges for the two analytes to fix that.

```{r}

#time series plot for two analytes with different y-axis ranges
(plot_bar_stack_abs_facet <- ggplot(data = wqdata_p8_nutrients, aes(x = Date, y = Value)) +
   geom_bar(stat = 'identity')+
  facet_grid(Nutrient~., scales = "free_y")
)

```

## Combined plots

Sometimes, it is useful to combine multiple plots into a panel that do not share a common x or y axis (i.e., are not produced using `facet_grid()` or `facet_wrap()`). These plot panels are particularly useful in publications like journal articles.

```{r}

#two side by side
plot_hist2 + plot_bar_stack_abs

#two stacked
plot_hist2 / plot_bar_stack_abs

#one large on left and two small stacked on right
plot_bar2+(plot_hist2 / plot_bar_stack_abs)


```


## Customizing plots

As I mentioned at the outset, one of the greatest advances of using R to make graphs is that you can customize them endlessly. We will touch on just a few common types of customizations. 

We will use the Secchi depth time series again. Previously, we used color to help differentiate the two stations, but we just used the default colors. We can specify the exact colors we want. We can also change the size, shape, and color of the points and the line type, width, and color. 


```{r}

#basic time series plot with connecting lines for both stations
(plot_ts_points_lines_two <- ggplot(data = wqdata, aes(x = Date, y = Secchi)) +
  geom_point(aes(color = Station))+
  geom_line(aes(color = Station)))

#different point types for different stations
(plot_ts_points_lines_two_pts <- ggplot(data = wqdata, aes(x = Date, y = Secchi)) +
  geom_point(aes(color = Station, shape = Station))+
  geom_line(aes(color = Station)))

#different line types for different stations
(plot_ts_points_lines_two_pts <- ggplot(data = wqdata, aes(x = Date, y = Secchi)) +
  geom_point(aes(color = Station, shape = Station))+
  geom_line(aes(color = Station, linetype = Station)))

#adjust point sizes and line widths
(plot_ts_points_lines_two_pts <- ggplot(data = wqdata, aes(x = Date, y = Secchi)) +
  geom_point(aes(color = Station, shape = Station), size = 3)+
  geom_line(aes(color = Station, linetype = Station), size = 1.2))


#Customize colors 
(plot_ts_points_lines_two_custom <- ggplot(data = wqdata, aes(x = Date, y = Secchi)) +
  geom_point(aes(color = Station, shape = Station), size = 3)+
  geom_line(aes(color = Station, linetype = Station), size = 1.2)+
  scale_color_manual(values =c("midnightblue","darkorange3"))
)

#Customize point shapes 
(plot_ts_points_lines_two_custom <- ggplot(data = wqdata, aes(x = Date, y = Secchi)) +
  geom_point(aes(color = Station, shape = Station), size = 3)+
  geom_line(aes(color = Station, linetype = Station), size = 1.2)+
  scale_color_manual(values =c("midnightblue","darkorange3")) +
  scale_shape_manual(values = c(15,17))
)


#Customize line types
(plot_ts_points_lines_two_custom <- ggplot(data = wqdata, aes(x = Date, y = Secchi)) +
  geom_point(aes(color = Station, shape = Station), size = 3)+
  geom_line(aes(color = Station, linetype = Station), size = 1.2)+
  scale_color_manual(values =c("midnightblue","darkorange3")) +
  scale_shape_manual(values = c(15,17)) +
  scale_linetype_manual(values = c("dotted","longdash"))
)



```

So far, we have used the default color palette in `ggplot2` as well as some customized colors. There are also a variety of R packages with thoughtfully developed color palettes. One example is the `viridis` package, which includes palettes are both attractive and color blind friendly. 

```{r}

#Use color palette
#our Sechi depth plot isn't a great example so we will go back to our Microcystis scores plot
(plot_bar <- ggplot(data = wqdata_means, aes(x = factor(Microcystis), y = temp_mean, fill = factor(Microcystis))) +
   geom_bar(stat = 'identity')+
   scale_fill_viridis(discrete = T)
   )


```


There are also options for formatting the plot background. Many people dislike the default gray background with grid lines.


```{r}
#change background from gray with white grid to white with gray grid
(plot_background_bw <- plot_ts_points_lines_two_custom + 
  theme_bw()
)

(plot_background_classic <- plot_ts_points_lines_two_custom + 
  theme_classic()
)

```

In addition, we can customize the names used to label the x-axis and y-axis and add plot titles. It is important to provide good labels for your plot axes. In particular, make sure to include the measurement units when relevant. I don't personally use plot title much, but they can be quickly inform your audience about the purpose of the plot. 

```{r}
(plot_labels <- plot_background +
  labs(x = "Sampling Date"
       , y = "Secchi depth (cm)"
       ,title = "Secchi depth comparison"
       )
)

```


## Saving plots

In RStudio, you can right click on a plot to copy it and then paste it elsewhere (e.g., email, word document), which works fine as a quick and dirty approach. However, a better way to export a plot involves using the ggsave() function. We will export our customized Secchi depth comparison plot.

```{r}
ggsave(plot = plot_labels #tell ggsave which plot to export
       , filename = "images/secchi_depth_comp.png" #provide the name for the image file
       , width = 6, height =4, units = "in" #dimensions of the exported image
       , dpi = 300 #resolution of the image (dots per inch)
       )
```

I used PNG which is a file type that works well for viewing on a computer. However, `ggsave()` can save plots as PDF, JPEG, TIFF, and various others. Search for `ggsave()` within 'Help' to see the full list of file types.

By default, the plot will be saved in your working directory. I specified a subfolder within my working directory.


## Additional resources




